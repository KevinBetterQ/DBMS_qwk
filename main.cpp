#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "conio.h"
#include "windows.h"
#include "iostream"
#include "power.h"

#include <sstream>



using namespace std;


#define MAX_PROLEN 10	//最大属性字符长度
#define MAX_PRONUM 8	//最大属性个数
#define MAX_RECNUM 30	//最大记录个数
#define MAX_TNAME 15	//最长表名
#define MAX_TNUM 15		//最大表个数
#define MAX_VIEWNUM 15		//最大表个数
#define MAX_USERLEN 10	//用户名长度
#define MAX_PWDLEN 18	//密码最大长度
#define MAX_USERNUM 10	//用户名最大个数

//***************************
typedef struct
{
	int re_num;		//记录的个数
	int pro_num;	//属性个数
	int key_no;		//规定关键字是第几个属性,使用的是下标从0开始
	//int pro_len[MAX_PRONUM];	//属性长度
	char key[MAX_PROLEN];		//定义关键字,关键字也是一个属性
	char tname[MAX_TNAME];		//表名
	char proname[MAX_PRONUM][MAX_PROLEN];	//属性的名字
	char protype[MAX_PRONUM];	//属性的类型
	char record[MAX_RECNUM][MAX_PRONUM][MAX_PROLEN];		//三维表,保存的内容是记录的值
}table;

typedef struct
{
	char proname[MAX_PRONUM][MAX_PROLEN];	//可见的属性
	int prono[MAX_PRONUM];		//可见属性的下标
	char tname[MAX_TNAME];		//对应的表名
	char vname[MAX_TNAME];		//视图名
	int pro_num;
}view;		//视图，该试图对应一个表，一个表可以对应多个视图

typedef struct
{
	char iname[MAX_TNAME];		//一个索引对应一个表
	int key_num;
	char key[MAX_RECNUM][MAX_PROLEN];	//
}index;
typedef struct
{
	char username[MAX_USERLEN];
	char pwd[MAX_PWDLEN];
	int revoke;		//0是管理员，1是普通用户
	int r_select;
	int r_delete;
	int r_update;
	int r_insert;
	char r_table[MAX_TNUM][MAX_TNUM];
}user;

table NULLTABLE;	//空表，初始化的时候定义NULLTABLE.key_no=-1
table t[MAX_TNUM];
view vi[MAX_VIEWNUM];
index ind[MAX_TNUM];

user u[MAX_USERNUM];
FILE *alfp;

int t_num=0;
int i_num=0;
int v_num=0;
int u_num=0;

int CURRENTREVOKE;
user currentuser;
int speedfactor=10;

//初始化表
void initialize()
{
	int i,j,k,p;
	t_num=0;
	NULLTABLE.key_no=-1;	//空表的定义就是key_no是-1的表，也是一种标识
	for(i=0;i<MAX_TNUM;i++)
	{
		for(j=0;j<MAX_PRONUM;j++)
			t[i].key[j]='\0';
		t[i].key_no=0;
		t[i].pro_num=0;
		t[i].re_num=0;
		for(j=0;j<MAX_PRONUM;j++)
			t[i].protype[j]='\0';
		for(j=0;j<MAX_PRONUM;j++)
			for(k=0;k<MAX_PROLEN;k++)
				t[i].proname[j][k]='\0';
		for(j=0;j<MAX_TNAME;j++)
			t[i].tname[j];
		for(j=0;j<MAX_RECNUM;j++)
			for(k=0;k<MAX_PRONUM;k++)
				for(p=0;p<MAX_PROLEN;p++)
					t[i].record[j][k][p]='\0';
	}
}

//用户与登陆
void login()
{
	u_num=4;
	strcpy(u[0].username,"0");
	strcpy(u[0].pwd,"0");
	u[0].revoke=0;
	strcpy(u[1].username,"a");
	strcpy(u[1].pwd,"a");
	u[1].revoke=0;
	u[1].r_delete=0;
	u[1].r_insert=0;
	u[1].r_select=0;
	u[1].r_update=0;
	strcpy(u[2].username,"qwk");
	strcpy(u[2].pwd,"qwk");
	u[2].revoke=1;
	u[2].r_delete=1;
	u[2].r_insert=1;
	u[2].r_select=1;
	u[2].r_update=1;
	strcpy(u[3].username,"1");
	strcpy(u[3].pwd,"1");
	u[3].revoke=1;
	int t=1;
ag:	clrscr();
	PrintStringXY(24,7, "┏━━━━━━━━━━━━━━┓");
	PrintStringXY(24,8, "┃                            ┃");
	PrintStringXY(24,9, "┣━━━━━━━━━━━━━━┫");
	PrintStringXY(24,10,"┃  用户名:                   ┃");
	PrintStringXY(24,11,"┣━━━━━━━━━━━━━━┫");
	PrintStringXY(24,12,"┃  密码  :                   ┃");
	PrintStringXY(24,13,"┗━━━━━━━━━━━━━━┛");
	PrintColorStringXY(36,8,0,7,0,15,"用户登陆");

	int i;
	char username[MAX_USERLEN];
	char pwd[MAX_PWDLEN];
	gotoxy(37,10);
	gets(username);
	//***************************
	for(i=0;i<u_num;i++)
	{//acc
		if(strcmp(username,u[i].username)==0)
			break;
		if((strcmp(username,u[i].username)!=0)&&(i==u_num-1))
		{
			if(t==3)
			{
				PrintStringXY(3,24,"错误次数达到三次,系统强行退出.\a按任意键退出.");
				getch();
				exit(-1);
			}
			PrintStringXY(3,24,"没有该用户名,请核对后再输入.\a按任意键返回.");
			getch();
			t++;
			goto ag;
		}
	}
	//***************************
	gotoxy(37,12);
	strcpy(pwd,InputStarString());
//***********************************************************
	for(i=0;i<u_num;i++)
	{
		if(strcmp(username,u[i].username)==0)
		{
			if(strcmp(pwd,u[i].pwd)==0)
			{
				printf("\n\n\n登陆成功，按任意键进入...");
				CURRENTREVOKE=u[i].revoke;
				currentuser=u[i];
				getch();
				clrscr();
				return;
			}
		}
	}
	if(t==3)
	{
		PrintStringXY(3,24,"错误次数达到三次,系统强行退出.\a按任意键退出.");
		getch();
		exit(-1);
	}
	PrintStringXY(3,24,"\a密码错误，请校对后再使用，按任意键返回...");
	getch();
	t++;
	goto ag;
//***********************************************************
}


//---------锁文件相关------------------------------------------------

//判断是否上锁，1代表锁
bool dbislock()
{
	int databaselock;
	FILE *fp;
	if((fp=fopen("dblock.db","rb"))==NULL)
	{
		printf("不存在锁文件,请检查后再使用.\a");
		fclose(fp);
		exit(-1);
	}
	fread(&databaselock,sizeof(int),1,fp);
	fclose(fp);
	if(databaselock==1)
		return true;
	else
		return false;
}
void dblock()
{
	int databaselock=1;
	FILE *fp;
	if((fp=fopen("dblock.db","wb"))==NULL)
	{
		printf("不存在锁文件,请检查后再使用\n");
		fclose(fp);
		exit(-1);
	}
	fwrite(&databaselock,sizeof(int),1,fp);
	fclose(fp);
}
void dbunlock()
{
	int databaselock=0;
	FILE *fp;
	if((fp=fopen("dblock.db","wb"))==NULL)
	{
		printf("不存在锁文件,请检查后再使用.\a");
		fclose(fp);
		exit(-1);
	}
	fwrite(&databaselock,sizeof(int),1,fp);
	fclose(fp);
}
void StronglySetLock0()//管理员的强制解锁
{
	int databaselock=0;	//强制设定锁的状态为开
	FILE *fp;
	if((fp=fopen("dblock.db","wb"))==NULL)
		fp=fopen("dblock.db","wb+");
	fwrite(&databaselock,sizeof(int),1,fp);
	fclose(fp);
	PrintStringXY(1,24,"\a已经将锁置为开,任意键返回...");
	getch();
}

//---------一些判断相关------------------------------------------------
bool IsRecEqu(table *r,int i,table *s,int j)
{
	int p;
	if(r->pro_num!=s->pro_num)		//属性个数不匹配
		return false;
	for(p=0;p<s->pro_num;p++)		//属性名字不匹配
		if(strcmp(s->proname[p],r->proname[p])!=0)
			return false;
	for(p=0;p<r->pro_num;p++)
		if(strcmp(r->record[i][p],s->record[j][p])!=0)
			return false;
	return true;
}
bool IsTableSameType(table *t1,table *t2)
{
	int p;
	if(t1->pro_num!=t2->pro_num)
	{
		gotoxy(1,20);printf("ErrorNo1:unequal number of properities.");
		return false;
	}
	for(p=0;p<t1->pro_num;p++)
		if(strcmp(t1->proname[p],t2->proname[p])!=0)
		{
			gotoxy(1,20);printf("ErrorNo2:different proname[%d]",p);
			return false;
		}
	return true;
}



//-------表的操作---------------------------------------------------
void tablecreate()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁
		dblock();	//dblock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];
	char ck[MAX_PROLEN];
	table tnew;
	int nnum;
	int i,j,k;
	gotoxy(37,7);setcolor(0,14);
	printf("建表操作");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入新建表的名称:");
	gets(mn);
	//添加重名处理与错误处理
	strcpy(tnew.tname,mn);	//新表表名
	gotoxy(27,10); printf("输入新建表的属性个数:");
	cin>>nnum;
	//添加错误处理
	if(nnum>=MAX_TNUM)
	{
		gotoxy(1,20);printf("已经达到表的最大个数,无法建表\a!");
		goto eotc1;
	}
	tnew.pro_num=nnum;
	//开始循环输入属性名称;
	//注意重名的属性
	gotoxy(1,15);
	i=0;
	while(i<tnew.pro_num)
	{
		printf("\n请输入第%d个属性名称:",i+1);
		cin>>mn;
		//重名处理!!!!!
		strcpy(tnew.proname[i],mn);
		printf("\n请输入第%d个属性类型n=num  c=char:",i+1);
		//错误处理,不符合的类型要排除掉!
		cin>>tnew.protype[i];
		i++;
	}

	//定义主键,主键是唯一表示一个记录的属性,必须要有主键.主键的位置是tnew.key,主键在属性中的下标.
	printf("\n主键对于一个表是必不可少的.\n");
	printf("请输入主键的名称,输入错误则自动选择第一个属性:");
	cin>>ck;
	for(i=0;i<tnew.pro_num;i++)
	{
		if(strcmp(ck,tnew.proname[i])==0)
		{
			tnew.key_no=i;
			strcpy(tnew.key,ck);
			goto nex1;
		}
	}
	printf("\n输入错误,主键自动选择为第一个属性:  \a%s",tnew.proname[0]);
	strcpy(tnew.key,tnew.proname[0]);
	tnew.key_no=0;
nex1:;
	tnew.re_num=0;		//记录表设置为空
	for(i=0;i<MAX_RECNUM;i++)
		for(j=0;j<MAX_PRONUM;j++)
			for(k=0;k<MAX_PROLEN;k++)
				tnew.record[i][j][k]='\0';	//初始化记录表
	t[t_num++]=tnew;
	printf("\n建表成功,回车返回上一级菜单.");
	getch();
eotc1:;
	dbunlock();		//解锁
	fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
									GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
	fprintf(alfp,"用户建立表成功,表的内容是:表名:%s,表属性个数:%d,主键:%s.",tnew.tname,
								tnew.pro_num,tnew.key);fputc('\n',alfp);
}
void tablecreate2();

void tabledrop()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];
	int i,j;
	table tdel;
	gotoxy(37,7);setcolor(0,14);
	printf("表删除操作");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入删除的表名:");
	cin>>mn;
	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			tdel=t[i];
			for(j=i;j<t_num-1;j++)
				t[j]=t[j+1];
			t_num--;
			goto eodrp;
		}
	gotoxy(1,20);printf("未找到要删除的表,请确认输入.\a");
	getchar();
	dbunlock();
	return;
eodrp:;
	gotoxy(1,20);
	printf("表%s被成功的删除!回车返回上一级菜单.",mn);
	getch();
	dbunlock();
		fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
									GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
	fprintf(alfp,"用户成功删除一个表,表的内容是:表名:%s,表属性个数:%d,主键:%s.",tdel.tname,
								tdel.pro_num,tdel.key);fputc('\n',alfp);
}

void tableprint(table *t1)//输出表
{
	int m,n;
	printf("\n-----------------------------------------\n");
	for(m=0;m<t1->pro_num;m++)
		printf("%s\t",t1->proname[m]);
	printf("\n-----------------------------------------\n");
	for(m=0;m<t1->re_num;m++)
	{
		for(n=0;n<t1->pro_num;n++)
			printf("%s\t",t1->record[m][n]);
		printf("\n\n");
	}
}

void outputts()		//表项信息显示
{
	clrscr();
	int i,j;
	for(i=0;i<t_num;i++)
	{
		printf("\n表名:%s   属性个数:%d    主键:%s",t[i].tname,t[i].pro_num,t[i].key);
		printf("\n----------------------------------------------------------------\n");
		for(j=0;j<t[i].pro_num;j++)
		{
			printf("%s(%c)\t",t[i].proname[j],t[i].protype[j]);
		}
		printf("\n\n");
	}
	getchar();
}



//---------记录的操作-----------------------------------------------
void recordinsert()//插入
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];
	char mq[MAX_TNAME];
	int i,j;
	gotoxy(37,7);setcolor(0,14);
	printf("记录插入操作");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入插入的表名:");
	gets(mn);

	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			goto eodrp;
		}
	gotoxy(1,20);printf("未找到要删除的表,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrp:;//找到表所在位置,接下来是插入记录动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(mq,mn);		//本函数到最后用到mq变量
	if(t[i].re_num>=MAX_RECNUM)
	{
		gotoxy(1,20);printf("该表已经达到记录的最大值!无法插入.\a");
		getch();
		if(dbislock())
		dbunlock();
		return;
	}
	gotoxy(1,20);
	for(j=0;j<t[i].pro_num;j++)
	{
		printf("\n请输入属性%s的值:",t[i].proname[j]);
		gets(mn);
		//添加错误处理,包括主键不可以重复等等.
		strcpy(t[i].record[t[i].re_num][j],mn);		//把属性值赋给相应的记录属性位置.
				//re_num++
		//////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	t[i].re_num++;

	printf("\n表%s已经被成功地插入了一个新记录!回车返回上一级菜单.",mq);
	getch();
	if(dbislock())
		dbunlock();
}
void recorddel()//删除
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];
	char mq[MAX_TNAME];
	char zj[MAX_PROLEN];
	int i,j,k;
	gotoxy(37,7);setcolor(0,14);
	printf("记录删除操作");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入删除记录的表名:");
	gets(mn);

	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			goto eodrd;
		}
	gotoxy(1,20);printf("未找到要删除记录的表,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrd:;
	//找到表所在位置,接下来是插入记录动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(mq,mn);		//本函数到最后用到mq变量
	if(t[i].re_num<=0)
	{
		gotoxy(1,20);printf("该表无记录!无法删除.\a");
		getch();
		if(dbislock())
			dbunlock();
		return;
	}
	gotoxy(27,10); printf("输入要删除记录的主键值:");
	gets(zj);	//输入主键的值
	//添加错误处理,判断是否有词记录
	for(j=0;j<t[i].re_num;j++)
	{
		if( strcmp( t[i].record[j][t[i].key_no] , zj ) ==0)
			goto findkey1;
	}
	gotoxy(1,20);printf("未找到该记录,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
findkey1:;
	//找到该记录,开始进行删除操作.j就是要删除的记录的下标
	for(;j<t[i].re_num-1;j++)
	{
		for(k=0;k<t[i].pro_num;k++)
			strcpy(t[i].record[j][k],t[i].record[j+1][k]);
	}
	t[i].re_num--;
	printf("\n表%s已经被成功地删除了一个记录!回车返回上一级菜单.",mq);
	getch();
	if(dbislock())
		dbunlock();
}
void outputrec()//显示
{
	clrscr();
	int i,j,k;
	for(i=0;i<t_num;i++)
	{
		printf("\n表名:%s   属性个数:%d    主键:%s",t[i].tname,t[i].pro_num,t[i].key);
		printf("\n----------------------------------------------------------------\n");
		for(j=0;j<t[i].pro_num;j++)
		{
			printf("%s\t",t[i].proname[j]);
		}
		printf("\n----------------------------------------------------------------\n");
		for(k=0;k<t[i].re_num;k++)
		{
			for(j=0;j<t[i].pro_num;j++)
				printf("%s\t",t[i].record[k][j]);
			printf("\n");
		}
		printf("\n\n按回车键输出下一张表...\n");
		getchar();
	}
	printf("\n表输出结束，按回车返回上一级菜单.");
	getchar();
}
void recordupdate()////更改
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];
	char mq[MAX_TNAME];
	char zj[MAX_PROLEN];
	int i,j,k;
	gotoxy(37,7);setcolor(0,14);
	printf("记录更改操作");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入记录所在的表名:");
	gets(mn);

	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			goto eodrp;
		}
	gotoxy(1,20);printf("未找到要删除的表,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrp:;//找到表所在位置,接下来是插入记录动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(mq,mn);		//本函数到最后用到mq变量
	if(t[i].re_num<=0)
	{
		gotoxy(1,20);printf("该表记录值为0!无法更改.\a");
		getch();
		if(dbislock())
			dbunlock();
		return;
	}
	//从这里开始搜寻主键的值
	gotoxy(27,10); printf("输入记录主键值:");
	gets(zj);	//输入主键的值
	//添加错误处理,判断是否有词记录
	printf("   key_no=%d   ",t[i].key_no);
	for(j=0;j<t[i].re_num;j++)
	{
		if( strcmp( t[i].record[j][t[i].key_no] , zj ) ==0)
			goto findkey1;
	}
	gotoxy(1,20);printf("未找到该记录,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
	//找到该记录,开始进行删除操作.j就是记录的下标,i是表的下标
findkey1:;
	gotoxy(1,20);
	for(k=0;k<t[i].pro_num;k++)
	{
		printf("\n请输入属性%s的值:",t[i].proname[k]);
		gets(mn);
		//添加错误处理,包括主键不可以重复等等.
		strcpy(t[i].record[j][k],mn);		//把属性值赋给相应的记录属性位置.
				//re_num++
	}

	printf("\n表%s成功修改了一条记录!回车返回上一级菜单.",mq);
	getch();
	if(dbislock())
		dbunlock();
}



//---------索引的操作-----------------------------------------------
void indexcreate()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];	//为了错误处理所建立的变量
	int i,j;
	index inew;
	setcolor(0,14);
	gotoxy(37,7);setcolor(0,14);
	printf("建立索引");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入索引表名:");
	gets(mn);
	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			goto eodrp;
		}
	gotoxy(1,20);printf("未找到该表,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrp:;//找到表所在位置,接下来是建立索引动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(inew.iname,mn);
	inew.key_num=t[i].key_no;
	for(j=0;j<t[i].re_num;j++)
		strcpy(inew.key[j],t[i].record[j][t[i].key_no]);
	gotoxy(1,20);printf("在表%s上成功建立了索引,回车返回上一级菜单.",mn);
	ind[i_num++]=inew;
	getch();
	if(dbislock())
		dbunlock();
}
void indexdrop()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	if(dbislock())
		dbunlock();
}
void indexshow()			//显示索引内容，并且输入索引项，显示该项的具体内容!!
{
	clrscr();
	char mn[MAX_TNAME];
	int i,j,k;
	gotoxy(37,7);setcolor(0,14);
	printf("显示索引");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入索引表名:");
	gets(mn);
	for(i=0;i<i_num;i++)
		if(strcmp(mn,ind[i].iname)==0)
			goto aas;
	printf("\a\n没有找到该索引!");
	getchar();
	return;
aas:;
	for(j=0;j<t_num;j++)
		if(strcmp(mn,t[j].tname)==0)
			break;
			cout<<j<<"+";
	gotoxy(1,20);
	printf("\n\n索引表名:%s   索引的主键为:%s\n",ind[i].iname,t[j].key);
	printf("\n-------------------------------------");
	for(k=0;k<=t[j].re_num;k++)
        for(int ji=0;ji<t[j].pro_num;ji++)
		printf("\t%s",t[j].record[k][ji]);
	printf("\n\n显示了输入索引的记录内容\n");
	getchar();

}


//---------视图的操作-----------------------------------------------
bool IsInView(view *v1,char *proname)
{
	int i;
	for(i=0;i<v1->pro_num;i++)
		if(strcmp(v1->proname[i],proname)==0)
			return true;
	return false;
}

void viewcreate()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];	//为了错误处理所建立的变量
	char zj[MAX_PROLEN];
	int pnum;
	int i,j,k;
	view vnew;
	gotoxy(37,7);setcolor(0,14);
	printf("建立视图");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入视图名:");
	gets(vnew.vname);	//输入视图名
	//添加错误处理，重名的视图等等
	gotoxy(27,10); printf("输入视图对应的表名:");
	gets(mn);
	for(i=0;i<t_num;i++)
		if(strcmp(t[i].tname,mn)==0)
			goto sse;
	gotoxy(1,20);printf("没有找到该表,请确认输入\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
sse:;
	//找到 该表，i就是表的下标
	strcpy(vnew.tname,mn);
	gotoxy(1,20);
	printf("请输入视图显示的属性个数:");
	cin>>pnum;
	vnew.pro_num=pnum;
	//加入错误处理，在这里 不多说了。
	k=0;
	while(k<pnum)
	{
		printf("\n请输入第%个属性名:",k+1);
		gets(zj);
		strcpy(vnew.proname[k],zj);
		for(j=0;j<t[i].pro_num;j++)
			if(strcmp(t[i].proname[j],zj)==0)
				goto asqq;
		printf("\a\n没有找到该属性.");
		getch();
		if(dbislock())
			dbunlock();
		return;
asqq:;
		vnew.prono[k]=j;
		k++;
	}
	vi[v_num++]=vnew;
	printf("成功建立了视图%s",vnew.vname);
	getch();
	if(dbislock())
			dbunlock();
}
void viewdrop()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	clrscr();
	char mn[MAX_TNAME];	//为了错误处理所建立的变量
	int i;
	gotoxy(37,7);setcolor(0,14);
	printf("放弃视图");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入视图名:");
	gets(mn);	//输入视图名
	//添加错误处理，重名的视图等等
	if(v_num<=0)
	{
		gotoxy(1,20);
		printf("视图数为0，无法删除视图\a");
	}
	for(i=0;i<v_num;i++)
	{
		if(strcmp(mn,vi[i].vname)==0)
			goto ae;
	}
	printf("\n没有找到该视图%s\a",mn);
	getch();
	if(dbislock())
		dbunlock();
	return;
ae:;for(;i<v_num-1;i++)
		vi[i]=vi[i+1];
	v_num--;
	printf("\n删除视图成功! 按回车返回上一级菜单。");
	getch();
	if(dbislock())
		dbunlock();
}
void viewtable()
{
	clrscr();
	char mn[MAX_TNAME];
	int i,j,k,p;
	gotoxy(37,7);setcolor(0,14);
	printf("视图查看表单");setcolor(0,15);
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入视图名:");
	gets(mn);	//输入视图名
	//判断视图是否存在
	for(i=0;i<v_num;i++)
		if(strcmp(vi[i].vname,mn)==0)
			goto val1;
	gotoxy(1,20);printf("不存在的视图名!\a");
	getch();
	return;
val1:;//发现该视图，编号为i
	for(j=0;j<t_num;j++)
		if(strcmp(vi[i].tname,t[j].tname)==0)
			break;
	//j为表名的下标

    gotoxy(1,20);
	printf("\n表名:%s   属性个数:%d    主键:%s",t[j].tname,t[j].pro_num,t[j].key);
		printf("\n----------------------------------------------------------------\n");
		for(k=0;k<t[j].pro_num;k++)
		{
			if(IsInView(&vi[i],t[j].proname[k]))
				printf("%s\t",t[j].proname[k]);
		}
		printf("\n----------------------------------------------------------------\n");
		for(k=0;k<t[j].re_num;k++)
		{
			for(p=0;p<t[j].pro_num;p++)
				if(IsInView(&vi[i],t[j].proname[p]))
					printf("%s\t",t[j].record[k][p]);
			printf("\n");
		}
	getch();
}


//---------表的运算（用于SQL查询）-----------------------------------------------
table yununion(table *t1,table *t2)
{
	table tnew;	//结果集
	int k,p,m,q;
		if(!IsTableSameType(t1,t2))
	{
		printf("\n所输入的两个表并不是同一个类型的!\a");
		getchar();
		return NULLTABLE;
	}
//并操作，把T1表赋值给结果集
	tnew.key_no=t1->key_no;
	tnew.pro_num=t1->pro_num;
	tnew.re_num=t1->re_num;
	strcpy(tnew.key,t1->key);
	strcpy(tnew.tname,"T");
	for(k=0;k<t1->pro_num;k++)
	{
		strcpy(tnew.proname[k],t1->proname[k]);
		tnew.protype[k]=t1->protype[k];
	}
	for(k=0;k<tnew.re_num;k++)
		for(p=0;p<tnew.pro_num;p++)
			strcpy(tnew.record[k][p],t1->record[k][p]);	//表T就是结果集

	for(p=0;p<t2->re_num;p++)
		for(q=0;q<t1->re_num;q++)
		{
			if(IsRecEqu(t1,q,t2,p))	//记录相等。
				break;
			if((q==t1->re_num-1)&&(!IsRecEqu(t1,q,t2,p)))
			{
				for(m=0;m<t1->pro_num;m++)
					strcpy(tnew.record[tnew.re_num][m],t2->record[p][m]);
				tnew.re_num++;
			}
		}
	return tnew;
}
table yunjiao(table *t1,table *t2)
{
	table tnew;
	int m,q,p,k;
	//这里加入，如果两个表不是同类表的错误处理
	if(!IsTableSameType(t1,t2))
	{
		gotoxy(1,20);
		printf("所输入的两个表并不是同一个类型的!\a");
		getchar();
		return NULLTABLE;
	}
	tnew.key_no=t1->key_no;
	tnew.pro_num=t1->pro_num;	//使结果集T的表类型和R,S相同
	tnew.re_num=0;		//把空集Φ给结果集T
	strcpy(tnew.key,t1->key);
	strcpy(tnew.tname,"T");
	for(k=0;k<t1->pro_num;k++)
	{
		strcpy(tnew.proname[k],t1->proname[k]);
		tnew.protype[k]=t1->protype[k];
	}
//交操作开始了

	for(p=0;p<t2->re_num;p++)
		for(q=0;q<t1->re_num;q++)
		{
			if(IsRecEqu(t1,q,t2,p))	//记录相等。
			{
				for(m=0;m<t1->pro_num;m++)
					strcpy(tnew.record[tnew.re_num][m],t2->record[p][m]);
				tnew.re_num++;
				break;
			}
		}
	return tnew;
}
table yundiff(table *t1,table *t2)
{
	table tnew;
	int k,m,n,p,q;
		//这里加入，如果两个表不是同类表的错误处理
	if(!IsTableSameType(t1,t2))
	{
		gotoxy(1,20);
		printf("所输入的两个表并不是同一个类型的!\a");
		getchar();
		return NULLTABLE;
	}

	tnew.key_no=t1->key_no;
	tnew.pro_num=t1->pro_num;
	tnew.re_num=t1->re_num;
	strcpy(tnew.key,t1->key);
	strcpy(tnew.tname,"T");
	for(k=0;k<t1->pro_num;k++)
	{
		strcpy(tnew.proname[k],t1->proname[k]);
		tnew.protype[k]=t1->protype[k];
	}
	for(k=0;k<tnew.re_num;k++)
		for(p=0;p<tnew.pro_num;p++)
			strcpy(tnew.record[k][p],t1->record[k][p]);	//表T就是结果集,结果集的内容就是R
//开始差操作了！！！
	for(p=0;p<t2->re_num;p++)
		for(q=0;q<tnew.re_num;q++)
		{
			if(IsRecEqu(&tnew,q,t2,p))	//记录相等。
			{
				for(m=q;m<tnew.re_num;m++)
					for(n=0;n<tnew.pro_num;n++)
						strcpy(tnew.record[m][n],tnew.record[m+1][n]);
				tnew.re_num--;
				break;
			}
		}
	return tnew;
}
table yunshadow(table *t1,char pro[MAX_PRONUM][MAX_PROLEN],int k)
{
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	table *t1			是表的指针
	char pro[][]		是投影属性的名称，二维，第一维是属性序号，第二维是属性名
	int k				是投影出的属性的个数
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
	table tnew;
	int m,n,p;
	for(m=0;m<=k;m++)
	{
		strcpy(tnew.proname[m],pro[m]);
		//这里tnew.protype就不多做了，因为实用性不强，并且操作比价复杂。
	}
	tnew.pro_num=k;
	tnew.key_no=0;
	tnew.re_num=t1->re_num;
	strcpy(tnew.tname,"T");
	for(m=0;m<t1->re_num;m++)		//记录的变化
	{
		for(n=0;n<t1->pro_num;n++)	//属性的变化
		{
			for(p=0;p<tnew.pro_num;p++)
				if(strcmp(t1->proname[n],tnew.proname[p])==0)
				{
					strcpy(tnew.record[m][p],t1->record[m][n]);
				}	//找到对应项，加入到新表中去
		}
	}
	return tnew;
}
table yunsel0(table *t1,char *sx,int ysf,int shu,char *str)	//检查好了再往函数里传
{
	table tnew;
	int m,n,k;
	//先初始化tnew表，使得tnew表与t1表同类型
	tnew.pro_num=t1->pro_num;
	tnew.key_no=t1->key_no;
	tnew.re_num=0;
	strcpy(tnew.tname,"T");
	for(m=0;m<t1->pro_num;m++)
		strcpy(tnew.proname[m],t1->proname[m]);
	//再判断sx区域的下标是多少。
	for(k=0;k<tnew.pro_num;k++)
		if(strcmp(tnew.proname[k],sx)==0)
			break;
	//k就是sx的下标，后面用着方便!!!
	for(m=0;m<t1->re_num;m++)
	{
		//1.＝  2.≠  3.≤  4.≥  5.＜  6.＞
		if(ysf==1)		//1.＝
		{
			if(strcmp(t1->record[m][k],str)==0)
			{
				for(n=0;n<t1->pro_num;n++)
					strcpy(tnew.record[tnew.re_num][n],t1->record[m][n]);
				tnew.re_num++;
			}
		}
		else if(ysf==2)	//2.≠
		{
			if(strcmp(t1->record[m][k],str)!=0)
			{
				for(n=0;n<t1->pro_num;n++)
					strcpy(tnew.record[tnew.re_num][n],t1->record[m][n]);
				tnew.re_num++;
			}
		}
		else if(ysf==3)	//3.≤
		{
			if(strtonum(t1->record[m][k])<=shu)
			{
				for(n=0;n<t1->pro_num;n++)
					strcpy(tnew.record[tnew.re_num][n],t1->record[m][n]);
				tnew.re_num++;
			}
		}
		else if(ysf==4)	//4.≥
		{
			if(strtonum(t1->record[m][k])>=shu)
			{
				for(n=0;n<t1->pro_num;n++)
					strcpy(tnew.record[tnew.re_num][n],t1->record[m][n]);
				tnew.re_num++;
			}
		}
		else if(ysf==5)	//5.＜
		{
			if(strtonum(t1->record[m][k])<shu)
			{
				for(n=0;n<t1->pro_num;n++)
					strcpy(tnew.record[tnew.re_num][n],t1->record[m][n]);
				tnew.re_num++;
			}
		}
		else	//ysf==6//6.＞
		{
			if(strtonum(t1->record[m][k])>shu)
			{
				for(n=0;n<t1->pro_num;n++)
					strcpy(tnew.record[tnew.re_num][n],t1->record[m][n]);
				tnew.re_num++;
			}
		}
	}
	return tnew;
}


//---------SQL的操作-----------------------------------------------
//查询时对and判断
table seland(table *t,char *pro1,char o1,char *shu1,char *pro2,char o2,char *shu2)
{
	int shu,ysf;	//用整型变量保存运算符类别。
	table tnew1,tnew2;		//结果集
	table *tnull=NULL;

	//添加错误处理在调用本函数之前
	//找到表所在位置,表t[i]是查到的表.    ＝、≠、≤、≥、＜、＞
	switch(o1)
	{
		case '>':ysf=6;break;
		case '<':ysf=5;break;
		case '=':ysf=1;break;
		case '!':ysf=2;break;
	}
	if(ysf>2)
		shu=strtonum(shu1);	//3.≤  4.≥  5.＜  6.＞这四种是数值比较
	tnew1=yunsel0(t,pro1,ysf,shu,shu1);
//****************************************************************
//添加错误处理
	switch(o2)
	{
		case '>':ysf=6;break;
		case '<':ysf=5;break;
		case '=':ysf=1;break;
		case '!':ysf=2;break;
	}
	if(ysf>2)
		shu=strtonum(shu2);	//3.≤  4.≥  5.＜  6.＞这四种是数值比较

	tnew2=yunsel0(t,pro2,ysf,shu,shu2);
//***************************************************************
	tnew1=yunjiao(&tnew1,&tnew2);
	return tnew1;
}
//查询时对or判断
table selor(table *t,char *pro1,char o1,char *shu1,char *pro2,char o2,char *shu2)
{
	int shu,ysf;	//用整型变量保存运算符类别。
	table tnew1,tnew2;		//结果集
	table *tnull=NULL;

	//添加错误处理在调用本函数之前
	//找到表所在位置,表t[i]是查到的表.    ＝、≠、≤、≥、＜、＞
	switch(o1)
	{
		case '>':ysf=6;break;
		case '<':ysf=5;break;
		case '=':ysf=1;break;
		case '!':ysf=2;break;
	}
	if(ysf>2)
		shu=strtonum(shu1);	//3.≤  4.≥  5.＜  6.＞这四种是数值比较
	tnew1=yunsel0(t,pro1,ysf,shu,shu1);
//****************************************************************
//添加错误处理
	switch(o2)
	{
		case '>':ysf=6;break;
		case '<':ysf=5;break;
		case '=':ysf=1;break;
		case '!':ysf=2;break;
	}
	if(ysf>2)
		shu=strtonum(shu2);	//3.≤  4.≥  5.＜  6.＞这四种是数值比较

	tnew2=yunsel0(t,pro2,ysf,shu,shu2);
//***************************************************************
	tnew1=yununion(&tnew1,&tnew2);
	return tnew1;
}

void relationcalculate(char *large)
{
    if(currentuser.r_select==0){
        cout<<"对不起，您没有此权限"<<endl;
        return;
    }
    table t1;
    //例如select sno,sage from stu where sno<0003 and sage!=22;\n\n\n
	char tname[MAX_TNAME];
	char pro[MAX_PRONUM][MAX_PROLEN];	//将要投影的属性名称集合
	char pro1[MAX_PROLEN];
	char pro2[MAX_PROLEN];
	char shu1[8],shu2[8];
	char o1,o2;
	int i,j,k=0;	//用整型变量保存运算符类别。

	//*******************************错误处理from
	//以后添加其他出错处理，比如from where。
	int p;
	for(p=0;p<(int)strlen(large);p++)
	{
		if(strcmp(substr(large,p,4),"from")==0)
			break;
		if(strcmp(substr(large,p,4),"from")!=0 && p>(int)strlen(large)-4)
		{
			printf("格式不对,没有发现from关键字\n");
			getch();
			return;
		}
	}



	//******************************
	for(j=0;j<MAX_PRONUM;j++)
		strcpy(pro[j]," ");
	i=7;		//从select 后第一个非' '开始
	j=0;
	//select sno,sage from stu where sno=0001 and sage=22;
	//select sno,sage from stu where sno!=0003 and sage!=22;
	//select * from stu
//************************这里开始分析************************************
	int secret=0;
	if(large[i]=='*')
	{
		secret=1;
		i+=7;
	}
	else
	{
		while(large[i]!=' ')
		{
			while(large[i]!=',' && large[i]!=' ')
				pro[k][j++]=large[i++];	//给pro1赋值
			pro[k][j]='\0';
			j=0;
			if(large[i]==',')
				i++;
			k++;
		}
		i+=6;
	}
	//目前i的位置在tname的0下标上
	while((large[i]!=' '))
		tname[j++]=large[i++];	//给tname赋值
	tname[j]='\0';
	if(secret==1)
	{
		int p,q;
		for(p=0;p<t_num;p++)
		{
			if(strcmp(tname,t[p].tname)==0)
				break;
		}
		t1=t[p];
        goto qwkl;
		for(q=0;q<t[p].pro_num;q++)
			{strcpy(pro[q],t[p].proname[q]);}
	}
	j=0;
	i+=7;		//目前i的位置在pro1的0下标上
	while(large[i]!='>' && large[i]!='=' && large[i]!='<'&& large[i]!='!')
		pro1[j++]=large[i++];	//给pro1赋值
	pro1[j]='\0';
	j=0;
	o1=large[i++];	//目前i在o1上,给o1赋值
	if(large[i]=='=')
		i++;
	while(large[i]!=' ')
		shu1[j++]=large[i++];	//给shu1赋值
	shu1[j]='\0';
	j=0;			//i在' '上
	i++;
	char andor[4];
	while(large[i]!=' ')
		andor[j++]=large[i++];
	andor[j]='\0';
	j=0;
	i++;
	while(large[i]!='>' && large[i]!='=' && large[i]!='<' && large[i]!='!')
		pro2[j++]=large[i++];	//给pro2赋值
	pro2[j]='\0';
	j=0;
	//i在o2上
	o2=large[i++];	//目前i在o2上,给o2赋值
	if(large[i]=='=')
		i++;
	while(large[i]!=';')
		shu2[j++]=large[i++];	//给shu2赋值
	shu2[j]='\0';
	j=0;			//i在';'上
//************************************************************
	//这样就把一个大的large字符串拆分开来.

	for(i=0;i<t_num;i++)
		if(strcmp(tname,t[i].tname)==0)
		{
			//i的值就是表的位置.
			goto eodrp;
		}
	printf("未找到表,请确认输入.\n");
	getchar();
	return;
eodrp:;//找到表所在位置,表t[i]是查到的表.

	if(strcmp(andor,"and")==0)
		t1=seland(&t[i],pro1,o1,shu1,pro2,o2,shu2);
	else if(strcmp(andor,"or")==0)
		t1=selor(&t[i],pro1,o1,shu1,pro2,o2,shu2);
	else
		printf("\n\n error!!!\a\a");
	t1=yunshadow(&t1,pro,k);
qwkl:;
	tableprint(&t1);
}


//---------对SQL语句的判断-----------------------------------------------
        //创建表create table students
        //      (Sno char primary key,Sname char unique,Sage int)
void sqlcreate(char *sql){
    if(strcmp(substr(sql,7,5),"table")==0)
    {

        char mn[MAX_TNAME];
        char ck[MAX_PROLEN];
        table tnew;

        int i,j,k;
        int nnum=0;
        int ii,jj=0;
        for(ii=0; sql[ii]!='\0'; ii++)
        {
            if((sql[ii]=='(')||(sql[ii]==',')||(sql[ii]==' ')) {sql[ii]=' ';jj++;}
        }
        nnum=(jj-3+1)/2;
        istringstream ss(sql);
        char tmp[10];
        ss>>tmp;ss>>tmp;ss>>mn;
          if(CURRENTREVOKE==0)
        {
            printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
            getch();
            return;
        }
        if(!dbislock())		//没有锁，那就加锁
            dblock();	//dblock();
        else
        {
            clrscr();
            printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
            getch();
            return;
        }

        //添加重名处理与错误处理
        strcpy(tnew.tname,mn);	//新表表名


        //添加错误处理
        if(nnum>=MAX_TNUM)
        {
            printf("已经达到表的最大个数,无法建表\a!");
            goto eotc1;
        }
        tnew.pro_num=nnum;
        //开始循环输入属性名称;
        //注意重名的属性

        i=0;
        char mmm[MAX_TNAME];
        while(i<tnew.pro_num)
        {
            ss>>mmm;
            //重名处理!!!!!
            strcpy(tnew.proname[i],mmm);
            //错误处理,不符合的类型要排除掉!
            ss>>tnew.protype;
            i++;
        }

        //定义主键,主键是唯一表示一个记录的属性,必须要有主键.主键的位置是tnew.key,主键在属性中的下标.
        printf("请输入主键的名称,输入错误则自动选择第一个属性:");
        gets(ck);
        for(i=0; i<tnew.pro_num; i++)
        {
            if(strcmp(ck,tnew.proname[i])==0)
            {
                tnew.key_no=i;
                strcpy(tnew.key,ck);
                goto nex1;
            }
        }
        printf("\n输入错误,主键自动选择为第一个属性:\a%s",tnew.proname[0]);
        strcpy(tnew.key,tnew.proname[0]);
        tnew.key_no=0;
nex1:
        ;
        tnew.re_num=0;		//记录表设置为空
        for(i=0; i<MAX_RECNUM; i++)
            for(j=0; j<MAX_PRONUM; j++)
                for(k=0; k<MAX_PROLEN; k++)
                    tnew.record[i][j][k]='\0';	//初始化记录表
        t[t_num++]=tnew;
        printf("建表成功\n");
        getch();
eotc1:
        ;
        dbunlock();		//解锁
        fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
                GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
        fprintf(alfp,"用户建立表成功,表的内容是:表名:%s,表属性个数:%d,主键:%s.",tnew.tname,
                tnew.pro_num,tnew.key);
        fputc('\n',alfp);
    }
    if(strcmp(substr(sql,7,5),"index")==0){
        char mn[MAX_TNAME];	//
	    int i,j;
        index inew;

        int nnum=0;
        int ii,jj=0;
        for(ii=0; sql[ii]!='\0'; ii++)
        {
            if((sql[ii]=='(')||(sql[ii]==',')||(sql[ii]==' ')) {sql[ii]=' ';jj++;}
        }
        nnum=(jj-5)/2;
        istringstream ss(sql);
        char tmp[10];
        char mm2[10];
        ss>>tmp;ss>>tmp;ss>>mn;ss>>tmp;ss>>mm2;

        if(CURRENTREVOKE==0)
        {
            printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
            getch();
            return;
        }
        if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            dblock();	//dblock();     dbunlock();
        else
        {
            printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
            printf("\n按任意键返回...");
            getch();
            return;
        }


        //添加错误处理
        for(i=0; i<t_num; i++)
            if(strcmp(mm2,t[i].tname)==0)
            {
                //i的值就是要的位置.
                goto eodrp;
            }
        printf("未找到该表,请确认输入.\a");
        getch();
        if(dbislock())
            dbunlock();
        return;
eodrp:;//找到表所在位置,接下来是建立索引动作,表t[i]是查到的表.
        //添加判断,是否可以继续添加记录而不达到满值.错误处理
        strcpy(inew.iname,mn);
        inew.key_num=t[i].key_no;
        for(j=0; j<t[i].re_num; j++)
            strcpy(inew.key[j],t[i].record[j][t[i].key_no]);
        printf("在表%s上成功建立了索引%s\n",mm2,mn);
        ind[i_num++]=inew;
        getch();
        if(dbislock())
            dbunlock();

    }
    if(strcmp(substr(sql,7,4),"view")==0){

        char mn[MAX_TNAME];	//为了错误处理所建立的变量
	    char zj[MAX_PROLEN];
        int pnum;
        int i,j,k;
        view vnew;

        int ii,jj=0;
        for(ii=0; sql[ii]!='\0'; ii++)
        {
            if((sql[ii]=='(')||(sql[ii]==',')||(sql[ii]==' ')||(sql[ii]==';')) {sql[ii]=' ';jj++;}
            if(sql[ii]=='*'||(sql[ii]==';')) sql[ii]==' ';
        }

        istringstream ss(sql);
        char tmp[10];
        char mm2[10];
        ss>>tmp;ss>>tmp;ss>>vnew.vname;ss>>tmp;ss>>tmp;ss>>mm2;ss>>tmp;ss>>mn;
        cout<<mn<<"+";

        if(CURRENTREVOKE==0)
	{
		printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");

		getch();
		return;
	}



	for(i=0;i<t_num;i++)
		if(strcmp(t[i].tname,mn)==0)
			goto sse;
	printf("没有找到该表,请确认输入\n");
	getch();
	if(dbislock())
		dbunlock();
	return;
sse:;
	//找到 该表，i就是表的下标

	pnum=t[i].pro_num;
	vnew.pro_num=pnum;
	strcpy(vnew.tname,t[i].tname);
	//加入错误处理，在这里 不多说了。
	k=0;
	while(k<pnum)
	{
		strcpy(vnew.proname[k],t[i].proname[k]);
		vnew.prono[k]=k;
		k++;
	}
	vi[v_num++]=vnew;
	printf("成功建立了视图%s\n",vnew.vname);
	getch();
	if(dbislock())
			dbunlock();
    }
}
void sqlinsert(char *sql){
    if(currentuser.r_insert==0){
        cout<<"对不起，您没有此权限"<<endl;
        return;
    }
    char mn[MAX_TNAME];
	char mq[MAX_TNAME];
	int i,j;
	int nnum;
    int ii,jj=0;
        for(ii=0; sql[ii]!='\0'; ii++)
        {
            if((sql[ii]=='(')||(sql[ii]==',')||(sql[ii]==' ')||(sql[ii]==')')) {sql[ii]=' ';jj++;}
        }
        nnum=(jj-3)/2;
        istringstream ss(sql);
        char tmp[10];
        ss>>tmp;ss>>tmp;ss>>mn;ss>>tmp;

    if(CURRENTREVOKE==0)
	{
		printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}

	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要插入的表的位置.
			goto eodrp;
		}
	gotoxy(1,20);printf("未找到要插入的表,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrp:;//找到表所在位置,接下来是插入记录动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(mq,mn);		//本函数到最后用到mq变量
	if(t[i].re_num>=MAX_RECNUM)
	{
		printf("该表已经达到记录的最大值!无法插入.\a");
		getch();
		if(dbislock())
		dbunlock();
		return;
	}
	char mnn[10];
	for(j=0;j<t[i].pro_num;j++)
	{
		t[i].proname[j];
		ss>>mnn;
		//添加错误处理,包括主键不可以重复等等.
		strcpy(t[i].record[t[i].re_num][j],mnn);		//把属性值赋给相应的记录属性位置.
				//re_num++
		//////////////////////////////////////////////////////////////////////////////////////////////////////////
	}
	t[i].re_num++;

	printf("表%s已经被成功地插入了一个新记录.\n",mq);

	fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
                GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
        fprintf(alfp,"用户插入数据成功,内容是:表%s,表属性个数:%d,主键:%s.",t[i].tname,
                t[i].pro_num,t[i].key);
        fputc('\n',alfp);
	getch();
	if(dbislock())
		dbunlock();
}
void sqldelete(char *sql){
    if(currentuser.r_delete==0){
        cout<<"对不起，您没有此权限"<<endl;
        return;
    }

    int nnum;
    int ii,jj=0;

    if(CURRENTREVOKE==0)
	{
		printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	char mn[MAX_TNAME];
	char mq[MAX_TNAME];
	char zj[MAX_PROLEN];
	int i,j,k;

        for(ii=0; sql[ii]!='\0'; ii++)
        {
            if((sql[ii]=='=')||(sql[ii]=='(')||(sql[ii]==',')||(sql[ii]==' ')||(sql[ii]==')')) {sql[ii]=' ';jj++;}
        }
        nnum=(jj-3)/2;
        istringstream ss(sql);
        char tmp[10];
        char sno[10];char snober[10];
        ss>>tmp;ss>>tmp;ss>>mn;ss>>tmp;ss>>sno;ss>>snober;


     //添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			goto eodrd;
		}
	gotoxy(1,20);printf("未找到要删除记录的表,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrd:;
	//找到表所在位置,接下来是插入记录动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(mq,mn);		//本函数到最后用到mq变量
	if(t[i].re_num<=0)
	{
		printf("该表无记录!无法删除.\a");
		getch();
		if(dbislock())
			dbunlock();
		return;
	}

	//添加错误处理,判断是否有词记录
	int jjj;
	for(j=0;j<t[i].re_num;j++)
	{
		for(jjj=0;jjj<t[i].pro_num;jjj++)
		if(( strcmp( t[i].record[j][jjj],snober)==0))
			goto findkey1;
	}
	gotoxy(1,20);printf("未找到合适记录\n");

	fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
                GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
        fprintf(alfp,"用户删除数据成功,内容是:表%s,表属性个数:%d,主键:%s.",t[i].tname,
                t[i].pro_num,t[i].key);
        fputc('\n',alfp);

	getch();
	if(dbislock())
		dbunlock();
	return;
findkey1:;
	//找到该记录,开始进行删除操作.j就是要删除的记录的下标
	for(;j<t[i].re_num-1;j++)
	{
		for(k=0;k<t[i].pro_num;k++)
			strcpy(t[i].record[j][k],t[i].record[j+1][k]);
	}
	t[i].re_num--;
	printf("\n表%s已经被成功地删除了一个记录\n",mq);
	getch();
	if(dbislock())
		dbunlock();


}
void sqldrop(char *sql){
    if(strcmp(substr(sql,5,5),"table")==0){

        char mn[MAX_TNAME];
        int i,j;
        table tdel;
        istringstream ss(sql);
        char tmp[10];
        ss>>tmp;
        ss>>tmp;
        ss>>mn;
        if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}



	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要删除的表的位置.
			tdel=t[i];
			for(j=i;j<t_num-1;j++)
				t[j]=t[j+1];
			t_num--;
			goto eodrp;
		}
	gotoxy(1,20);printf("未找到要删除的表\n");
	getchar();
	dbunlock();
	return;
eodrp:;
	printf("表%s被成功的删除\n",mn);
	getch();
	dbunlock();
		fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
									GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
	fprintf(alfp,"用户成功删除一个表,表的内容是:表名:%s,表属性个数:%d,主键:%s.",tdel.tname,
								tdel.pro_num,tdel.key);fputc('\n',alfp);
    }
    if(strcmp(substr(sql,5,5),"index")==0){

        char mn[MAX_TNAME];	//为了错误处理所建立的变量
        int i;
        istringstream ss(sql);
        char tmp[10];
        ss>>tmp;
        ss>>tmp;
        ss>>mn;
        if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}



	//添加错误处理，重名的视图等等
	if(i_num<=0)
	{

		printf("索引数为0，无法删除索引\a");
	}
	for(i=0;i<i_num;i++)
	{
		if(strcmp(mn,ind[i].iname)==0)
			goto be;
	}
	printf("\n没有找到该索引%s\n",mn);
	getch();
	if(dbislock())
		dbunlock();
	return;
be:;
    for(;i<i_num-1;i++)
		ind[i]=ind[i+1];
	i_num--;
	printf("\n删除索引成功\n");
	getch();
	if(dbislock())
		dbunlock();
    }
    if(strcmp(substr(sql,5,4),"view")==0){
        char mn[MAX_TNAME];	//为了错误处理所建立的变量
        int i;
        istringstream ss(sql);
        char tmp[10];
        ss>>tmp;
        ss>>tmp;
        ss>>mn;
        if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}



	//添加错误处理，重名的视图等等
	if(v_num<=0)
	{

		printf("视图数为0，无法删除视图\a");
	}
	for(i=0;i<v_num;i++)
	{
		if(strcmp(mn,vi[i].vname)==0)
			goto ae;
	}
	printf("\n没有找到该视图%s\a",mn);
	getch();
	if(dbislock())
		dbunlock();
	return;
ae:;
    for(;i<v_num-1;i++)
		vi[i]=vi[i+1];
	v_num--;
	printf("\n删除视图成功\n");
	getch();
	if(dbislock())
		dbunlock();
    }

}
void sqlupdate(char *sql){
    if(currentuser.r_update==0){
        cout<<"对不起，您没有此权限"<<endl;
        return;
    }
	char mn[MAX_TNAME];
	char mq[MAX_TNAME];
	char zj[MAX_PROLEN];
	int i,j,k;
    int nnum;
    int ii,jj=0;
        for(ii=0; sql[ii]!='\0'; ii++)
        {
            if((sql[ii]==';')||(sql[ii]=='=')||(sql[ii]=='(')||(sql[ii]==',')||(sql[ii]==' ')||(sql[ii]==')')) {sql[ii]=' ';jj++;}
        }
        nnum=(jj-3)/2;
        istringstream ss(sql);
        char tmp[10];
        char sno[10];
        char snober[10];
        char sageber[10];
        char sage[10];
        ss>>tmp;ss>>mn;ss>>tmp;
        ss>>sage;ss>>sageber;ss>>tmp;ss>>sno;ss>>snober;


    if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}


	//添加错误处理
	for(i=0;i<t_num;i++)
		if(strcmp(mn,t[i].tname)==0)
		{
			//i的值就是要的表的位置.
			goto eodrp;
		}
	printf("未找到要更改的表,请确认输入.\n");
	getch();
	if(dbislock())
		dbunlock();
	return;
eodrp:;//找到表所在位置,接下来是插入记录动作,表t[i]是查到的表.
	//添加判断,是否可以继续添加记录而不达到满值.错误处理
	strcpy(mq,mn);		//本函数到最后用到mq变量
	if(t[i].re_num<=0)
	{
		printf("该表记录值为0!无法更改.\n");
		getch();
		if(dbislock())
			dbunlock();
		return;
	}
	int jjj;
	//添加错误处理,判断是否有词记录
	for(j=0;j<t[i].re_num;j++)
	{
		for(jjj=0;jjj<t[i].pro_num;jjj++)
		if( strcmp( t[i].record[j][jjj] , snober ) ==0)
			goto findkey1;
	}
	printf("未找到该记录,请确认输入.\a");
	getch();
	if(dbislock())
		dbunlock();
	return;
	//找到该记录,开始进行删除操作.j就是记录的下标,i是表的下标
findkey1:;

	for(k=0;k<t[i].pro_num;k++)
	{

		if( strcmp( t[i].proname[k] , sage ) ==0)
		strcpy(t[i].record[j][k],sageber);		//把属性值赋给相应的记录属性位置.
	}

	printf("表%s成功修改了一条记录\n",mq);
	getch();
	if(dbislock())
		dbunlock();
}
void sqlgrant(char *sql){
    if(CURRENTREVOKE==0)
	{
		printf("\a对不起,您的权限不允许这项操作.\n");
		getch();
		return;
	}
    istringstream ss(sql);
    char tmp[10];
    char ri[10];char riuser[10];
    ss>>tmp;ss>>ri;ss>>tmp;ss>>tmp;ss>>tmp;ss>>tmp;ss>>riuser;
    if(strcmp(ri,"select")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_select=1;cout<<"授权成功"<<endl;}
        }
    }
    else if(strcmp(ri,"update")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_update=1;cout<<"授权成功"<<endl;}
        }
    }
    else if(strcmp(ri,"delete")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_delete=1;cout<<"授权成功"<<endl;}
        }
    }
    else if(strcmp(ri,"insert")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_insert=1;cout<<"授权成功"<<endl;}
        }
    }
}
void sqlrevoke(char *sql){
    if(CURRENTREVOKE==0)
	{
		printf("\a对不起,您的权限不允许这项操作.\n");
		getch();
		return;
	}
    istringstream ss(sql);
    char tmp[10];
    char ri[10];char riuser[10];
    ss>>tmp;ss>>ri;ss>>tmp;ss>>tmp;ss>>tmp;ss>>tmp;ss>>riuser;
    if(strcmp(ri,"select")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_select=0;cout<<"撤销权利成功"<<endl;}
        }
    }
    else if(strcmp(ri,"update")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_update=0;cout<<"撤销权利成功"<<endl;}
        }
    }
    else if(strcmp(ri,"delete")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_delete=0;cout<<"撤销权利成功"<<endl;}
        }
    }
    else if(strcmp(ri,"insert")==0){
        for(int i=0;i<u_num;i++){
            if(strcmp(u[i].username,riuser)==0) {u[i].r_insert=0;cout<<"撤销权利成功"<<endl;}
        }
    }
}
//---------备份与恢复-----------------------------------------------
void BackUp()
{
	if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	char filename[20];
	clrscr();
	PrintColorStringXY(36,7,0,14,0,15,"数据的备份");
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入备份数据的文件名:");
	gotoxy(27,10);
	gets(filename);
	FILE *fp;
	if((fp=fopen(filename,"wb"))==NULL)
		fp=fopen(filename,"wb+");
	//以下共6个文件提供全体打包保存dblock.db,table.db,index.db,view.db,dic.db,log.txt
//*****************对dblock.db的备份********************************************
	int databaselock;
	if(dbislock())
		databaselock=1;
	else
		databaselock=0;
	fwrite(&databaselock,sizeof(int),1,fp);
	PrintStringXY(1,24,"备份dblock.db\a..   ");
	Sleep(300);
//******************对table.db的备份********************************************
	fwrite(&t_num,sizeof(int),1,fp);
	fwrite(t,sizeof(table),MAX_TNUM,fp);
	PrintStringXY(1,24,"备份table.db\a..   ");
	Sleep(300);
//******************对index.db的备份********************************************
	fwrite(&i_num,sizeof(int),1,fp);
	fwrite(ind,sizeof(index),MAX_TNUM,fp);
	PrintStringXY(1,24,"备份index.db\a..   ");
	Sleep(300);
//******************对view.db的备份**********************************************
	fwrite(&v_num,sizeof(int),1,fp);
	fwrite(vi,sizeof(view),MAX_VIEWNUM,fp);
	PrintStringXY(1,24,"备份view.db\a..   ");
	Sleep(300);
//******************对dic.db的备份***********************************************
	//dic.db是数据字典，不需要备份，只是在恢复的时候从table.db中分解出来即可.
//******************对log.txt的备份***********************************************
	FILE *fp1;
	char ch;
	if((fp1=fopen("log.txt","rb"))==NULL)
	{
		printf("不存在日志文件log.txt,本次备份未完全成功.\a");
		fp1=fopen("log.txt","wb+");
		fclose(fp1);
		fclose(fp);
		if(dbislock())
			dbunlock();
		return;
	}
	ch=fgetc(fp1);
	while(ch!=EOF)
	{
		fputc(ch,fp);
		ch=fgetc(fp1);

	}
	fclose(fp1);
	fclose(fp);
	PrintStringXY(1,24,"备份log.txt\a..   ");
	Sleep(300);
	PrintStringXY(1,24,"恭喜，所有数据已成功备份于");
	printf("%s",filename);
	printf("\n按任意键返回...");
	getch();
	if(dbislock())
		dbunlock();
}
void ReCovery()
{
	//对某个指定的备份进行恢复
		if(CURRENTREVOKE==0)
	{
		gotoxy(1,24);printf("\a对不起,您的权限不允许这项操作.按任意键返回...");
		getch();
		return;
	}
	if(!dbislock())		//没有锁，那就加锁@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		dblock();	//dblock();     dbunlock();
	else
	{
		clrscr();
		printf("数据库处于锁状态，即使超级用户也不能进行修改!\a");
		printf("\n按任意键返回...");
		getch();
		return;
	}
	char filename[20];
	clrscr();
	PrintColorStringXY(36,7,0,14,0,15,"数据的恢复");
	DrawFrame(20,60,5,14);
	gotoxy(27,9); printf("输入恢复数据的文件名:");
	gotoxy(27,10);
	gets(filename);
	FILE *fp;
	FILE *fp2;
	if((fp=fopen(filename,"rb"))==NULL)
	{
		PrintStringXY(1,24,"未发现此备份文件!按任意键返回...\a");
		getch();
		if(dbislock())
		dbunlock();
		return;
	}
	//以下文件提供全体读取dblock.db,table.db,index.db,view.db,log.txt
//*****************对dblock.db的恢复********************************************
	int databaselock;
	fread(&databaselock,sizeof(int),1,fp);
	if((fp2=fopen("dblock.db","wb"))==NULL)
		fp2=fopen("dblock.db","wb+");
	fwrite(&databaselock,sizeof(int),1,fp2);
	fclose(fp2);
	PrintStringXY(1,24,"恢复dblock.db\a..   ");
	Sleep(300);
//******************对table.db的恢复********************************************
	fread(&t_num,sizeof(int),1,fp);
	fread(t,sizeof(table),MAX_TNUM,fp);
	if((fp2=fopen("table.db","wb"))==NULL)
		fp2=fopen("table.db","wb+");
	fwrite(&t_num,sizeof(int),1,fp2);
	fwrite(t,sizeof(table),MAX_TNUM,fp2);
	fclose(fp2);
	PrintStringXY(1,24,"恢复table.db\a..   ");
	Sleep(300);
//******************对index.db的恢复********************************************
	fread(&i_num,sizeof(int),1,fp);
	fread(ind,sizeof(index),MAX_TNUM,fp);
	if((fp2=fopen("index.db","wb"))==NULL)
		fp2=fopen("index.db","wb+");
	fwrite(&i_num,sizeof(int),1,fp2);
	fwrite(ind,sizeof(index),MAX_TNUM,fp2);
	fclose(fp2);
	PrintStringXY(1,24,"恢复index.db\a..   ");
	Sleep(300);
//******************对view.db的恢复**********************************************
	fread(&v_num,sizeof(int),1,fp);
	fread(vi,sizeof(view),MAX_VIEWNUM,fp);
	if((fp2=fopen("view.db","wb"))==NULL)
		fp2=fopen("view.db","wb+");
	fwrite(&v_num,sizeof(int),1,fp2);
	fwrite(vi,sizeof(view),MAX_VIEWNUM,fp2);
	fclose(fp2);
	PrintStringXY(1,24,"恢复view.db\a..   ");
	Sleep(300);
//******************对dic.db的恢复***********************************************
	//dic.db是数据字典，不需要备份，只是在恢复的时候从table.db中分解出来即可.
	int i,j;
	if((fp2=fopen("dic.db","wb"))==NULL)
		fp2=fopen("dic.db","wb+");
	for(i=0;i<t_num;i++)
	{
		fprintf(fp2,"表名:%s   属性数量:%d   主键:%s",t[i].tname,t[i].pro_num,t[i].key);
		fprintf(fp2,"\n----------------------------------------------------\n");
		for(j=0;j<t[i].pro_num;j++)
			fprintf(fp2,"%s(%c)    ",t[i].proname[j],t[i].protype[j]);
		fprintf(fp,"\n\n\n");
	}
	fclose(fp2);
	PrintStringXY(1,24,"恢复dic.db\a..   ");
	Sleep(300);
//******************对log.txt的备份***********************************************
	char ch;
	if((fp2=fopen("log.txt","wb"))==NULL)
		fp2=fopen("dic.db","wb+");
	ch=fgetc(fp);
	while(ch!=EOF)
	{
		fputc(ch,fp2);
		ch=fgetc(fp);
	}
	fclose(fp2);
	fclose(fp);
	PrintStringXY(1,24,"恢复log.txt\a..   ");
	Sleep(300);
	PrintStringXY(1,24,"恭喜，所有数据已成功恢复自");
	printf("%s",filename);
	printf("\n按任意键返回...");
	getch();
	if(dbislock())
		dbunlock();
}
void filewrite()
{
	FILE *fp;
//*****************读取config.db内容
	if((fp=fopen("config.db","wb"))==NULL)
		fp=fopen("config.db","wb+");
	fwrite(&speedfactor,sizeof(int),1,fp);
	fclose(fp);
//写入table.db的代码
	if((fp=fopen("table.db","wb"))==NULL)
	{
		printf("不存在table.db文件,请检查后再使用.\a");
		getchar();
		exit(-1);
	}
	fwrite(&t_num,sizeof(int),1,fp);
	fwrite(t,sizeof(table),MAX_TNUM,fp);
	fclose(fp);
//以下是写入dic.db的代码
	int i,j;
	if((fp=fopen("dic.db","wb"))==NULL)
	{
		printf("不存在dic.db文件,请检查后再使用.\a");
		getchar();
		exit(-1);
	}
	for(i=0;i<t_num;i++)
	{
		fprintf(fp,"表名:%s   属性数量:%d   主键:%s",t[i].tname,t[i].pro_num,t[i].key);
		fprintf(fp,"\n----------------------------------------------------\n");
		for(j=0;j<t[i].pro_num;j++)
			fprintf(fp,"%s(%c)    ",t[i].proname[j],t[i].protype[j]);
		fprintf(fp,"\n\n\n");
	}
	fclose(fp);
//以下是写入view.db的代码
	if((fp=fopen("view.db","wb"))==NULL)
	{
		printf("不存在view.db文件,请检查后再使用.\a");
		getchar();
		exit(-1);
	}
	fwrite(&v_num,sizeof(int),1,fp);
	fwrite(vi,sizeof(view),MAX_VIEWNUM,fp);
	fclose(fp);
//以下是写入index.db的代码
	if((fp=fopen("index.db","wb"))==NULL)
	{
		printf("不存在index.db文件,请检查后再使用.\a");
		getchar();
		exit(-1);
	}
	fwrite(&i_num,sizeof(int),1,fp);
	fwrite(ind,sizeof(index),MAX_TNUM,fp);
	fclose(fp);
}


int main()
{
    if((alfp=fopen("log.txt","a"))==NULL)
		alfp=fopen("log.txt","w+");


	fprintf(alfp,"*******************************************");fputc('\n',alfp);
	fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
									GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
	fprintf(alfp,"初始化各项信息.");fputc('\n',alfp);
	initialize();//初始化表

	login();//用户登陆
	dbunlock();

	char sql[100];
	clrscr();
    gotoxy(1,8);

	while(1){
        //clrscr();
        cout<<"SQL> ";
        gets(sql);

    if(strcmp(sql,"exit")==0) break;
    else if(strcmp(sql,"su")==0) login();
    else if(strcmp(substr(sql,0,6),"select")==0){
        relationcalculate(sql);
    }
    else if(strcmp(substr(sql,0,6),"create")==0){
        sqlcreate(sql);
	}
	else if(strcmp(substr(sql,0,6),"insert")==0){
        sqlinsert(sql);
	}
	else if(strcmp(substr(sql,0,6),"delete")==0){
        sqldelete(sql);
	}
	else if(strcmp(substr(sql,0,6),"update")==0){
        sqlupdate(sql);
	}
	else if(strcmp(substr(sql,0,4),"drop")==0){
        sqldrop(sql);
	}
	else if(strcmp(substr(sql,0,5),"grant")==0){
        sqlgrant(sql);
	}
	else if(strcmp(substr(sql,0,6),"revoke")==0){
        sqlrevoke(sql);
	}

	else if(strcmp(sql,"help database")==0){
        outputrec();
        indexshow();
        viewtable();
        clrscr();
	}
	else if(strcmp(sql,"help table")==0){
        outputrec();
        clrscr();
	}
	else if(strcmp(sql,"help view")==0){
        viewtable();
        clrscr();
	}
	else if(strcmp(sql,"help index")==0){
        indexshow();
        clrscr();
	}
	else if(strcmp(sql,"备份")==0){
        filewrite();
        BackUp();
        clrscr();
	}
	else if(strcmp(sql,"恢复")==0){
        ReCovery();
        clrscr();
	}


	else cout<<"请正确输入..."<<endl;
	}

    filewrite();
	fprintf(alfp,"\n[%d年%d月%d日 %d:%d:%d]执行如下操作:\n",GetCurrentYear(),GetCurrentMonth(),GetCurrentDay(),
									GetCurrentHour(),GetCurrentMinute(),GetCurrentSecond() );
	fprintf(alfp,"用户正常退出操作.");fputc('\n',alfp);
	fclose(alfp);
	return 0;
}
